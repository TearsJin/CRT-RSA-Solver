

# This file was *autogenerated* from the file ./Attack/JMInteger.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0)
from time import time


bounds = [_sage_const_2 ,_sage_const_2 ]
m = _sage_const_3 
n = len(bounds)

PR = PolynomialRing(ZZ, names=('x', 'y',)); (x, y,) = PR._first_ngens(2)
f = x ** _sage_const_2  * y + x * y ** _sage_const_2  + _sage_const_2 
vars = [x,y]
Monomials = f.monomials() 
Coefficients = f.coefficients()
a = Integer(Coefficients[-_sage_const_1 ])

for i in range(n):
    while gcd(bounds[i],a) != _sage_const_1 :
        bounds[i] +=_sage_const_1  

# define dj
D = [_sage_const_0  for _ in range(len(vars))]
for j in range(len(D)):
    Max = _sage_const_0 
    for exp in f.exponents():
        if exp[j] > Max:
            Max = exp[j]
    D[j] = Max
factors = [monomial(*bounds) for monomial in Monomials]
W = max([i * j for i,j in zip(Coefficients,factors)])
R = W * prod([bounds[j] ** (D[j]*(m-_sage_const_1 )) for j in range(n)])
f = f * inverse_mod(a,R)
S = (f ** (m - _sage_const_1 )).monomials()
M = (f ** m).monomials()

g = lambda monomial,f:monomial*f*prod([bounds[j]**(D[j]*(m-_sage_const_1 )-monomial.exponents()[_sage_const_0 ][j]) for j in range(n)])
g_ = lambda monomial,f:monomial * R

ShiftPolys = Sequence([],f.parent())
for monomial in S:
    ShiftPolys.append(g(monomial,f))
for monomial in M:
    if monomial not in S:
        ShiftPolys.append(g_(monomial,f))

B, monomials = ShiftPolys.coefficient_matrix()
monomials = vector(monomials)
nn = len(monomials)

print("[+] Successfully defined polynomial.There are {} polynomials in total.".format(str(nn)))
# 获得单项式的顺序
monomialOrder = []
for Poly in ShiftPolys:
    for x in Poly.monomials():
        if x not in monomialOrder:
            monomialOrder.append(x)
# 将上界乘进系数矩阵
factors = [monomial(*bounds) for monomial in monomials]
for i, factor in enumerate(factors):
    B.rescale_col(i, factor)
# LLL
print("[+] Start LLL...")
LLLTime = _sage_const_0 
S = time()
B = B.dense_matrix().LLL()
LLLTime = time()-S
print("[+] LLL Done! The time taken is",LLLTime,"s")
B = B.change_ring(QQ)
for i, factor in enumerate(factors):
    B.rescale_col(i, _sage_const_1 /factor)
print("[+] Start finding the root...")
FindRootTime = _sage_const_0 
S = time()
# 求根
H = Sequence([], f.parent().change_ring(QQ))
for h in filter(None, B*monomials):
    H.append(h)
    I = H.ideal()
    if I.dimension() == -_sage_const_1 :
        H.pop()
    elif I.dimension() == _sage_const_0 :
        roots = []
        for root in I.variety(ring=ZZ):
            root = tuple(root[var] for var in [y,z])
            roots.append(root)
        for root in roots:
            if root != (_sage_const_1 ,_sage_const_0 ):
                print("[+] Successfully found the roots:",root)
                FindRootTime = time()-S
                print("[+] The time taken is",FindRootTime,"s")
    


