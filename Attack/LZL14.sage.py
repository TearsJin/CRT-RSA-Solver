

# This file was *autogenerated* from the file ./Attack/LZL14.sage
from sage.all_cmdline import *   # import sage library

_sage_const_123718923712936178236172831212381902312371892837122111111111111111 = Integer(123718923712936178236172831212381902312371892837122111111111111111); _sage_const_65537 = Integer(65537); _sage_const_123213 = Integer(123213); _sage_const_0p1 = RealNumber('0.1'); _sage_const_0p5 = RealNumber('0.5'); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0)
from time import time

'''
    LZL14 - LSBs
    dp < N ^ beta
    e < N ^ alpha
    d1 < N ^ delta

    dp = d1 * M + d0
'''

N = Integer(_sage_const_123718923712936178236172831212381902312371892837122111111111111111 )
e = _sage_const_65537 
d0 = _sage_const_123213 
alpha = float(log(e,N))
delta = _sage_const_0p1 
beta = _sage_const_0p5 
kbits = int(N.nbits() * delta ) # known bits
M = _sage_const_2  ** kbits # dp = d1 * M + d0
bounds = [N**(beta + alpha - _sage_const_0p5 ),N ** _sage_const_0p5 ,N ** _sage_const_0p5 ]
tau = _sage_const_0p5  - _sage_const_2  * delta 
sigma = _sage_const_0p5  + delta 
m = _sage_const_3 
t = int(tau * m)
s = int(sigma * m)

PR = PolynomialRing(ZZ, names=('x', 'y', 'z',)); (x, y, z,) = PR._first_ngens(3)
f = x * (y - _sage_const_1 ) - e * d0 + _sage_const_1  
g = lambda i,j:(e * M) ** (m - i) * x ** j * z ** s * f ** i
h = lambda i,j:(e * M) ** (m - i) * y ** j * z ** s * f ** i
Ix = [(i,j) for i in range(m + _sage_const_1 ) for j in range(m - i + _sage_const_1 )]
Iy = [(i,j) for i in range(m + _sage_const_1 ) for j in range(_sage_const_1 , t + _sage_const_1 )]

ShiftPolys = Sequence([],f.parent())
for _ in Ix:
    poly = g(*_)
    ShiftPolys.append(poly)
for _ in Iy:
    poly = h(*_)
    ShiftPolys.append(poly)
# 获得系数矩阵
B, monomials = ShiftPolys.coefficient_matrix()
monomials = vector(monomials)
nn = len(monomials)
print("[+] Successfully defined polynomial.There are {} polynomials in total.".format(str(nn)))
# 获得单项式的顺序
monomialOrder = []
for Poly in ShiftPolys:
    for x in Poly.monomials():
        if x not in monomialOrder:
            monomialOrder.append(x)
# 将上界乘进系数矩阵
factors = [monomial(*bounds) for monomial in monomials]
for i, factor in enumerate(factors):
    B.rescale_col(i, factor)
# LLL
print("[+] Start LLL...")
LLLTime = _sage_const_0 
S = time()
B = B.dense_matrix().LLL()
LLLTime = time()-S
print("[+] LLL Done! The time taken is",LLLTime,"s")
B = B.change_ring(QQ)
for i, factor in enumerate(factors):
    B.rescale_col(i, _sage_const_1 /factor)
print("[+] Start finding the root...")
FindRootTime = _sage_const_0 
S = time()
# 求根
H = Sequence([], f.parent().change_ring(QQ))
for h in filter(None, B*monomials):
    H.append(h)
    I = H.ideal()
    if I.dimension() == -_sage_const_1 :
        H.pop()
    elif I.dimension() == _sage_const_0 :
        roots = []
        for root in I.variety(ring=ZZ):
            root = tuple(root[var] for var in [x,y,z])
            roots.append(root)
        for root in roots:
            if root != (_sage_const_1 ,_sage_const_0 ):
                print("[+] Successfully found the roots:",root)
                FindRootTime = time()-S
                print("[+] The time taken is",FindRootTime,"s")

